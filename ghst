local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")

-- Get the local player (the player running this script)
local localPlayer = Players.LocalPlayer
local mouse = localPlayer:GetMouse()
local camera = workspace.CurrentCamera

-- Variables to track our targeting state
local isTargeting = false          -- Whether targeting is currently active
local targetPlayer = nil           -- The player we're targeting
local maxDistance = 500            -- Maximum distance to find targets (in studs)
local smoothness = 0.5             -- Default smoothness (0.1 to 1)
local highlight = nil              -- Highlight effect for the targeted player
local guiVisible = true            -- Whether the GUI is currently visible
local connections = {}             -- Store all connections for cleanup
local titleBarConnections = {}     -- For the title bar drag connections

-- Create a GUI for the camera lock settings
local function createGui()
    -- Create our main ScreenGui container
    local ghstGui = Instance.new("ScreenGui")
    ghstGui.Name = "ghst.lol"
    ghstGui.ResetOnSpawn = false
    
    -- Create the main frame
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(0, 200, 0, 100)
    mainFrame.Position = UDim2.new(0.85, 0, 0.1, 0)
    mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    mainFrame.BorderSizePixel = 0
    mainFrame.Active = false  -- Main frame should not be draggable
    mainFrame.Draggable = false
    mainFrame.Parent = ghstGui
    
    -- Add a title bar
    local titleBar = Instance.new("Frame")
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, 30)
    titleBar.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    titleBar.BorderSizePixel = 0
    titleBar.Parent = mainFrame
    
    -- Make the title bar draggable
    local isDraggingGui = false
    local dragOffset = Vector2.new(0, 0)
    
    local dragStart = titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            isDraggingGui = true
            local mousePos = UserInputService:GetMouseLocation()
            dragOffset = UDim2.new(0, mousePos.X, 0, mousePos.Y) - mainFrame.Position
        end
    end)
    
    local dragEnd = titleBar.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            isDraggingGui = false
        end
    end)
    
    local dragChange = UserInputService.InputChanged:Connect(function(input)
        if isDraggingGui and input.UserInputType == Enum.UserInputType.MouseMovement then
            local mousePos = UserInputService:GetMouseLocation()
            mainFrame.Position = UDim2.new(0, mousePos.X, 0, mousePos.Y) - dragOffset
        end
    end)
    
    -- Store the connections for cleanup
    table.insert(titleBarConnections, dragStart)
    table.insert(titleBarConnections, dragEnd)
    table.insert(titleBarConnections, dragChange)
    
    -- Add title text
    local titleText = Instance.new("TextLabel")
    titleText.Name = "TitleText"
    titleText.Size = UDim2.new(1, -30, 1, 0)  -- Make room for the X button
    titleText.BackgroundTransparency = 1
    titleText.Text = "ghst.lol"
    titleText.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleText.Font = Enum.Font.GothamBold
    titleText.TextSize = 16
    titleText.Parent = titleBar
    
    -- Create a TextButton with just an X symbol
    local unloadButton = Instance.new("TextButton")
    unloadButton.Name = "UnloadButton"
    unloadButton.Size = UDim2.new(0, 30, 0, 30)
    unloadButton.Position = UDim2.new(1, -30, 0, 0)
    unloadButton.BackgroundTransparency = 1 -- Make background transparent
    unloadButton.Text = "âœ•"  -- X symbol
    unloadButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    unloadButton.Font = Enum.Font.GothamBold
    unloadButton.TextSize = 16
    unloadButton.AutoButtonColor = false
    unloadButton.Parent = titleBar
    
    -- Hover effect for the unload button
    unloadButton.MouseEnter:Connect(function()
        unloadButton.TextColor3 = Color3.fromRGB(255, 0, 0)  -- Red when hovering
    end)
    
    unloadButton.MouseLeave:Connect(function()
        unloadButton.TextColor3 = Color3.fromRGB(255, 255, 255)  -- White when not hovering
    end)
    
    -- Status text (ON/OFF)
    local statusText = Instance.new("TextLabel")
    statusText.Name = "StatusText"
    statusText.Size = UDim2.new(1, 0, 0, 20)
    statusText.Position = UDim2.new(0, 0, 0, 35)
    statusText.BackgroundTransparency = 1
    statusText.Text = "Status: OFF (Press C to toggle)"
    statusText.TextColor3 = Color3.fromRGB(255, 255, 255)
    statusText.Font = Enum.Font.Gotham
    statusText.TextSize = 14
    statusText.Parent = mainFrame
    
    -- Smoothness slider text
    local smoothnessText = Instance.new("TextLabel")
    smoothnessText.Name = "SmoothnessText"
    smoothnessText.Size = UDim2.new(1, 0, 0, 20)
    smoothnessText.Position = UDim2.new(0, 0, 0, 55)
    smoothnessText.BackgroundTransparency = 1
    smoothnessText.Text = "Smoothness: 0.5"
    smoothnessText.TextColor3 = Color3.fromRGB(255, 255, 255)
    smoothnessText.Font = Enum.Font.Gotham
    smoothnessText.TextSize = 14
    smoothnessText.Parent = mainFrame
    
    -- Smoothness slider
    local smoothnessSlider = Instance.new("Frame")
    smoothnessSlider.Name = "SmoothnessSlider"
    smoothnessSlider.Size = UDim2.new(0.8, 0, 0, 5)
    smoothnessSlider.Position = UDim2.new(0.1, 0, 0, 80)
    smoothnessSlider.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    smoothnessSlider.BorderSizePixel = 0
    smoothnessSlider.Parent = mainFrame
    
    -- Slider knob
    local sliderKnob = Instance.new("Frame")
    sliderKnob.Name = "SliderKnob"
    sliderKnob.Size = UDim2.new(0, 10, 0, 15)
    sliderKnob.Position = UDim2.new(smoothness, -5, 0, -5)
    sliderKnob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    sliderKnob.BorderSizePixel = 0
    sliderKnob.Parent = smoothnessSlider
    
    -- Make the slider functional
    local isDragging = false
    local sliderConnections = {}
    
    -- Create a hitbox for better mouse detection
    local sliderHitbox = Instance.new("TextButton")
    sliderHitbox.Name = "SliderHitbox"
    sliderHitbox.Size = UDim2.new(0, 20, 0, 25)  -- Larger than the knob for easier clicking
    sliderHitbox.Position = UDim2.new(smoothness, -10, 0, -10)
    sliderHitbox.BackgroundTransparency = 1  -- Make it invisible
    sliderHitbox.Text = ""
    sliderHitbox.AutoButtonColor = false
    sliderHitbox.Parent = smoothnessSlider
    
    -- Connect events to the hitbox instead of the knob
    sliderHitbox.MouseButton1Down:Connect(function()
        isDragging = true
    end)
    
    -- Also handle directly clicking on the slider bar
    smoothnessSlider.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            -- Get mouse position relative to slider
            local mousePos = input.Position
            local sliderPos = smoothnessSlider.AbsolutePosition
            local sliderSize = smoothnessSlider.AbsoluteSize
            
            -- Calculate new position
            local newPos = (mousePos.X - sliderPos.X) / sliderSize.X
            newPos = math.clamp(newPos, 0, 1)
            
            -- Update knob and hitbox position
            sliderKnob.Position = UDim2.new(newPos, -5, 0, -5)
            sliderHitbox.Position = UDim2.new(newPos, -10, 0, -10)
            
            -- Update smoothness value
            smoothness = 0.1 + (newPos * 0.9)
            smoothnessText.Text = "Smoothness: " .. string.format("%.2f", smoothness)
            
            isDragging = true
        end
    end)
    
    -- Add connection to detect when mouse button is released anywhere
    local connection1 = UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            isDragging = false
        end
    end)
    
    -- Add connection for dragging behavior
    local connection2 = UserInputService.InputChanged:Connect(function(input)
        if isDragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            -- Get mouse position relative to slider
            local mousePos = UserInputService:GetMouseLocation()
            local sliderPos = smoothnessSlider.AbsolutePosition
            local sliderSize = smoothnessSlider.AbsoluteSize
            
            -- Calculate new smoothness (clamped between 0 and 1)
            local newPos = (mousePos.X - sliderPos.X) / sliderSize.X
            newPos = math.clamp(newPos, 0, 1)
            
            -- Update knob and hitbox positions
            sliderKnob.Position = UDim2.new(newPos, -5, 0, -5)
            sliderHitbox.Position = UDim2.new(newPos, -10, 0, -10)
            
            -- Update smoothness value (using range 0.1 to 1 for better control)
            smoothness = 0.1 + (newPos * 0.9)
            smoothnessText.Text = "Smoothness: " .. string.format("%.2f", smoothness)
        end
    end)
    
    -- Store connections so they can be cleaned up if needed
    table.insert(sliderConnections, connection1)
    table.insert(sliderConnections, connection2)
    
    -- Add the unload functionality to the unload button
    local unloadConnection = unloadButton.MouseButton1Click:Connect(function()
        -- Hide the GUI
        guiVisible = false
        ghstGui.Enabled = false
        
        -- If targeting is on, turn it off
        if isTargeting then
            isTargeting = false
            targetPlayer = nil
            
            -- Remove highlight if it exists
            if highlight then
                highlight:Destroy()
                highlight = nil
            end
        end
        
        -- Clean up all connections
        for _, connection in pairs(connections) do
            connection:Disconnect()
        end
        
        -- Clean up slider connections
        for _, connection in pairs(sliderConnections) do
            connection:Disconnect()
        end
        
        -- Clean up title bar connections
        for _, connection in pairs(titleBarConnections) do
            connection:Disconnect()
        end
        
        -- Disconnect the unload button's connection
        unloadConnection:Disconnect()
        
        -- Notify in output
        print("ghst.lol has been unloaded.")
    end)
    
    -- Store the unload connection for later reference
    table.insert(connections, unloadConnection)
    
    -- Store references to the GUI elements for later use
    local guiElements = {
        gui = ghstGui,
        statusText = statusText,
        smoothnessText = smoothnessText,
        mainFrame = mainFrame
    }
    
    -- Try to parent the GUI to the CoreGui if allowed, otherwise to PlayerGui
    pcall(function()
        ghstGui.Parent = CoreGui
    end)
    
    if not ghstGui.Parent then
        local playerGui = localPlayer:WaitForChild("PlayerGui")
        ghstGui.Parent = playerGui
    end
    
    return guiElements
end

-- Function to find the closest player to target
local function findClosestPlayer()
    local closestPlayer = nil
    local shortestDistance = maxDistance
    
    -- Loop through all players in the game
    for _, player in pairs(Players:GetPlayers()) do
        -- Skip the local player (we don't want to target ourselves)
        if player ~= localPlayer then
            -- Check if the player's character exists and they have a head
            if player.Character and player.Character:FindFirstChild("Head") and
               player.Character:FindFirstChild("HumanoidRootPart") and
               localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                
                -- Calculate the distance between our character and the target's head
                local distance = (localPlayer.Character.HumanoidRootPart.Position - player.Character.Head.Position).Magnitude
                
                -- If this player is closer than our current closest, update our target
                if distance < shortestDistance then
                    closestPlayer = player
                    shortestDistance = distance
                end
            end
        end
    end
    
    return closestPlayer
end

-- Create the GUI for our camlock settings
local guiElements = createGui()

-- Function to apply highlight to a player
local function applyHighlight(player)
    -- Remove any existing highlight
    if highlight then
        highlight:Destroy()
        highlight = nil
    end
    
    if player and player.Character then
        -- Create a new highlight
        highlight = Instance.new("Highlight")
        highlight.Name = "TargetHighlight"
        highlight.FillColor = Color3.fromRGB(255, 0, 0)  -- Red color
        highlight.FillTransparency = 0.7  -- 70% transparency to see through it
        highlight.OutlineColor = Color3.fromRGB(255, 0, 0)  -- Red outline
        highlight.OutlineTransparency = 0.3  -- 30% transparency for outline
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop  -- Make it visible through walls
        highlight.Adornee = player.Character  -- Apply to the whole character
        highlight.Parent = player.Character  -- Parent to the character
    end
end

-- Function to toggle the targeting system on/off
local function toggleTargeting()
    isTargeting = not isTargeting
    
    if isTargeting then
        -- When targeting is turned on, find a target
        guiElements.statusText.Text = "Status: ON (Press C to toggle)"
        guiElements.statusText.TextColor3 = Color3.fromRGB(0, 255, 0)
        targetPlayer = findClosestPlayer()
        
        -- Apply highlight to the targeted player
        if targetPlayer then
            applyHighlight(targetPlayer)
        end
    else
        -- When targeting is turned off, clear the target
        guiElements.statusText.Text = "Status: OFF (Press C to toggle)"
        guiElements.statusText.TextColor3 = Color3.fromRGB(255, 255, 255)
        targetPlayer = nil
        
        -- Remove highlight
        if highlight then
            highlight:Destroy()
            highlight = nil
        end
    end
end

-- Connect to the input service to detect when the C key is pressed
local inputConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
    -- Only process if we're not in a text box or something
    if not gameProcessed then
        -- Check if the C key was pressed to toggle targeting
        if input.KeyCode == Enum.KeyCode.C then
            -- Only activate if GUI is visible
            if guiVisible then
                toggleTargeting()
            end
        end
    end
end)

-- Store the connection for cleanup
table.insert(connections, inputConnection)

-- Function that runs every frame to update the camera if targeting is on
local function updateCamera()
    -- Only run the targeting code if the necessary conditions are met
    if isTargeting and targetPlayer and 
       localPlayer.Character and targetPlayer.Character and
       localPlayer.Character:FindFirstChild("HumanoidRootPart") and
       targetPlayer.Character:FindFirstChild("Head") then
        
        -- Get the positions we need
        local rootPosition = localPlayer.Character.HumanoidRootPart.Position
        local targetPosition = targetPlayer.Character.Head.Position
        
        -- Check if target is still in range
        local distance = (rootPosition - targetPosition).Magnitude
        if distance > maxDistance then
            -- Target moved too far away, find a new target
            targetPlayer = findClosestPlayer()
            if not targetPlayer then
                return
            end
        end
        
        -- Apply highlight to the targeted player regardless of camera mode
        if highlight == nil or targetPlayer.Character ~= highlight.Adornee then
            applyHighlight(targetPlayer)
        end

        -- Always control the camera when targeting is on
        local currentCFrame = camera.CFrame
        
        -- Get the target CFrame (where we want the camera to look)
        local targetCFrame = CFrame.new(currentCFrame.Position, targetPosition)
        
        -- Smoothly interpolate between current and target CFrame based on smoothness
        camera.CFrame = currentCFrame:Lerp(targetCFrame, smoothness)
    end
end

-- Connect our camera update function to RunService's RenderStepped event
local cameraConnection = RunService.RenderStepped:Connect(updateCamera)

-- Store this connection for cleanup
table.insert(connections, cameraConnection)

-- Print initial instructions
print("=== ghst.lol Camera Lock Script ===")
print("Press 'C' to toggle camera lock on/off")
print("Use the X button to unload the GUI and features")
print("Adjust smoothness with the slider")
