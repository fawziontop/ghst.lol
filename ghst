-- Created by irokzzz

-- Required services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local GuiService = game:GetService("GuiService")
local HttpService = game:GetService("HttpService")

-- Player and camera references
local localPlayer = Players.LocalPlayer
local camera = workspace.CurrentCamera

-- Settings
local maxDistance = 200  -- Maximum distance to target players
local smoothness = 0.5   -- Initial smoothness for camera movements (1 = instant, 0 = no movement)
local walkspeed = 100    -- Initial walkspeed (max 500)
local originalWalkspeed = nil  -- To store the original walkspeed

-- Default key bindings
local camlockKey = Enum.KeyCode.C  -- Default key to toggle camera lock
local walkspeedKey = Enum.KeyCode.V  -- Default key to toggle walkspeed

-- Key names for display
local keyNames = {
    [Enum.KeyCode.C] = "C",
    [Enum.KeyCode.X] = "X",
    [Enum.KeyCode.F] = "F",
    [Enum.KeyCode.V] = "V",
    [Enum.KeyCode.RightControl] = "Right Ctrl",
    -- Add more keys as needed
}

-- Variables for tracking state
local isTargeting = false  -- Is camera lock active?
local targetPlayer = nil   -- Which player we're targeting
local highlight = nil      -- Highlight effect on target
local guiVisible = true    -- Is our GUI visible?
local walkspeedActive = false -- Is walkspeed active?
local connections = {}     -- Store all connections to disconnect them later

-- Default key for toggling GUI visibility
local toggleGuiKey = Enum.KeyCode.RightControl  -- Right Ctrl key

-- GUI elements
local guiElements = {}

-- Function to create the GUI
local function createGui()
    -- Create a ScreenGui to hold everything
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ghst.lol_GUI"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    -- Create the main frame with rounded corners
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(0, 280, 0, 320)
    mainFrame.Position = UDim2.new(0.5, -140, 0.5, -160) -- Centered on screen
    mainFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0) -- Pure black background
    mainFrame.BorderSizePixel = 0
    mainFrame.Active = true
    mainFrame.Draggable = false  -- We'll handle dragging manually
    mainFrame.ClipsDescendants = true
    mainFrame.ZIndex = 9999 -- Ensure it's on top of everything
    mainFrame.Parent = screenGui
    
    -- Add corner radius to main frame
    local mainCorner = Instance.new("UICorner")
    mainCorner.CornerRadius = UDim.new(0, 10)
    mainCorner.Parent = mainFrame
    
    -- Add drop shadow effect
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "Shadow"
    shadow.AnchorPoint = Vector2.new(0.5, 0.5)
    shadow.BackgroundTransparency = 1
    shadow.Position = UDim2.new(0.5, 0, 0.5, 4)
    shadow.Size = UDim2.new(1, 20, 1, 20)
    shadow.ZIndex = -1
    shadow.Image = "rbxassetid://1316045217"
    shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
    shadow.ImageTransparency = 0.6
    shadow.ScaleType = Enum.ScaleType.Slice
    shadow.SliceCenter = Rect.new(10, 10, 118, 118)
    shadow.Parent = mainFrame
    
    -- Create a subtle gradient background for the main frame
    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(10, 10, 10)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
    })
    gradient.Rotation = 45
    gradient.Parent = mainFrame
    
    -- Create a title bar with gradient
    local titleBar = Instance.new("Frame")
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, 40)
    titleBar.Position = UDim2.new(0, 0, 0, 0)
    titleBar.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
    titleBar.BorderSizePixel = 0
    titleBar.ZIndex = 2
    titleBar.Parent = mainFrame
    
    -- Add corner radius to title bar (only top corners)
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 10)
    titleCorner.Parent = titleBar
    
    -- Add a gradient to the title bar
    local titleGradient = Instance.new("UIGradient")
    titleGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(20, 20, 20)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(5, 5, 5))
    })
    titleGradient.Rotation = 90
    titleGradient.Parent = titleBar
    
    -- Fix the bottom corners of title bar
    local bottomFrame = Instance.new("Frame")
    bottomFrame.Size = UDim2.new(1, 0, 0, 10)
    bottomFrame.Position = UDim2.new(0, 0, 1, -10)
    bottomFrame.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
    bottomFrame.BorderSizePixel = 0
    bottomFrame.ZIndex = 2
    bottomFrame.Parent = titleBar
    
    -- Apply same gradient to bottom frame
    local bottomGradient = titleGradient:Clone()
    bottomGradient.Parent = bottomFrame
    
    -- Make the title bar draggable
    local dragging = false
    local dragInput = nil
    local dragStart = nil
    local startPos = nil
    
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = mainFrame.Position
        end
    end)
    
    titleBar.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            dragInput = input
        end
    end)
    
    local dragConnection = RunService.RenderStepped:Connect(function()
        if dragging and dragInput and dragStart then
            local delta = dragInput.Position - dragStart
            mainFrame.Position = UDim2.new(
                startPos.X.Scale, 
                startPos.X.Offset + delta.X, 
                startPos.Y.Scale, 
                startPos.Y.Offset + delta.Y
            )
        end
    end)
    
    -- Store the connection for cleanup
    table.insert(connections, dragConnection)
    
    -- Title with logo and text
    local logoContainer = Instance.new("Frame")
    logoContainer.Name = "LogoContainer"
    logoContainer.Size = UDim2.new(0, 36, 0, 36)
    logoContainer.Position = UDim2.new(0, 10, 0, 2)
    logoContainer.BackgroundTransparency = 1
    logoContainer.ZIndex = 3
    logoContainer.Parent = titleBar
    
    -- Create a skull logo from image provided by user
    local skullImageLogo = Instance.new("ImageLabel")
    skullImageLogo.Name = "SkullImageLogo"
    skullImageLogo.Size = UDim2.new(0, 30, 0, 30) -- Size to fit the logo container
    skullImageLogo.Position = UDim2.new(0.5, -15, 0.5, -15) -- Center in the container
    skullImageLogo.BackgroundTransparency = 1
    skullImageLogo.Image = "rbxassetid://16012654984" -- Updated skull logo (Roblox asset ID)
    skullImageLogo.ImageColor3 = Color3.fromRGB(255, 255, 255) -- Ensure it's white
    skullImageLogo.ScaleType = Enum.ScaleType.Fit -- Scale to fit while maintaining aspect ratio
    skullImageLogo.ZIndex = 3
    skullImageLogo.Parent = logoContainer
    
    -- Title text
    local titleText = Instance.new("TextLabel")
    titleText.Name = "TitleText"
    titleText.Size = UDim2.new(1, -90, 1, 0)
    titleText.Position = UDim2.new(0, 55, 0, 0)
    titleText.BackgroundTransparency = 1
    titleText.Text = "ghst.lol"
    titleText.Font = Enum.Font.GothamBold
    titleText.TextSize = 18
    titleText.TextColor3 = Color3.fromRGB(250, 250, 250)
    titleText.TextXAlignment = Enum.TextXAlignment.Left
    titleText.ZIndex = 3
    titleText.Parent = titleBar
    
    -- Subtitle text (empty as requested)
    local subtitleText = Instance.new("TextLabel")
    subtitleText.Name = "SubtitleText"
    subtitleText.Size = UDim2.new(0, 100, 0, 20)
    subtitleText.Position = UDim2.new(0, 55, 0, 20)
    subtitleText.BackgroundTransparency = 1
    subtitleText.Text = ""
    subtitleText.Font = Enum.Font.Gotham
    subtitleText.TextSize = 12
    subtitleText.TextColor3 = Color3.fromRGB(180, 180, 190)
    subtitleText.TextXAlignment = Enum.TextXAlignment.Left
    subtitleText.ZIndex = 3
    subtitleText.Parent = titleBar
    
    -- Close button (X)
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 30, 0, 30)
    closeButton.Position = UDim2.new(1, -35, 0, 5)
    closeButton.BackgroundTransparency = 1
    closeButton.Text = "âœ•"
    closeButton.Font = Enum.Font.GothamBold
    closeButton.TextSize = 20
    closeButton.TextColor3 = Color3.fromRGB(255, 100, 100)
    closeButton.ZIndex = 3
    closeButton.Parent = titleBar
    
    -- Add hover effect to close button
    closeButton.MouseEnter:Connect(function()
        closeButton.TextColor3 = Color3.fromRGB(255, 50, 50)
    end)
    
    closeButton.MouseLeave:Connect(function()
        closeButton.TextColor3 = Color3.fromRGB(255, 100, 100)
    end)
    
    -- Create a divider under the title bar
    local divider = Instance.new("Frame")
    divider.Name = "Divider"
    divider.Size = UDim2.new(1, -20, 0, 2)
    divider.Position = UDim2.new(0, 10, 0, 40)
    divider.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
    divider.BorderSizePixel = 0
    divider.Transparency = 0.5
    divider.ZIndex = 2
    divider.Parent = mainFrame
    
    local dividerGradient = Instance.new("UIGradient")
    dividerGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(60, 60, 70, 0)),
        ColorSequenceKeypoint.new(0.3, Color3.fromRGB(80, 80, 100)),
        ColorSequenceKeypoint.new(0.7, Color3.fromRGB(80, 80, 100)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(60, 60, 70, 0))
    })
    dividerGradient.Parent = divider
    
    -- The main GUI content with padding
    local contentContainer = Instance.new("Frame")
    contentContainer.Name = "ContentContainer"
    contentContainer.Size = UDim2.new(1, 0, 1, -45)
    contentContainer.Position = UDim2.new(0, 0, 0, 45)
    contentContainer.BackgroundTransparency = 1
    contentContainer.Parent = mainFrame
    
    -- Add padding to content
    local padding = Instance.new("UIPadding")
    padding.PaddingLeft = UDim.new(0, 15)
    padding.PaddingRight = UDim.new(0, 15)
    padding.PaddingTop = UDim.new(0, 15)
    padding.PaddingBottom = UDim.new(0, 10)
    padding.Parent = contentContainer
    
    -- =============== CAMERA LOCK SECTION WITH SLIDER ===============
    local camlockSection = Instance.new("Frame")
    camlockSection.Name = "CamlockSection"
    camlockSection.Size = UDim2.new(1, 0, 0, 110) -- Taller to fit smoothness slider
    camlockSection.Position = UDim2.new(0, 0, 0, 0)
    camlockSection.BackgroundTransparency = 1
    camlockSection.Parent = contentContainer
    
    -- Camera Lock section title
    local camlockTitle = Instance.new("TextLabel")
    camlockTitle.Name = "SectionTitle"
    camlockTitle.Size = UDim2.new(1, 0, 0, 20)
    camlockTitle.BackgroundTransparency = 1
    camlockTitle.Text = "CAMERA LOCK"
    camlockTitle.Font = Enum.Font.GothamBold
    camlockTitle.TextSize = 12
    camlockTitle.TextColor3 = Color3.fromRGB(255, 255, 255) -- Pure white
    camlockTitle.TextXAlignment = Enum.TextXAlignment.Left
    camlockTitle.Parent = camlockSection
    
    -- Camera Lock Status container
    local statusContainer = Instance.new("Frame")
    statusContainer.Name = "StatusContainer"
    statusContainer.Size = UDim2.new(1, 0, 0, 30)
    statusContainer.Position = UDim2.new(0, 0, 0, 20)
    statusContainer.BackgroundColor3 = Color3.fromRGB(25, 25, 35) -- Darker background
    statusContainer.BorderSizePixel = 0
    statusContainer.Parent = camlockSection
    
    -- Round the corners
    local statusCorner = Instance.new("UICorner")
    statusCorner.CornerRadius = UDim.new(0, 6)
    statusCorner.Parent = statusContainer
    
    -- Status text for camera lock
    local statusText = Instance.new("TextLabel")
    statusText.Name = "StatusText"
    statusText.Size = UDim2.new(0.65, 0, 1, 0)
    statusText.Position = UDim2.new(0.03, 0, 0, 0)
    statusText.BackgroundTransparency = 1
    statusText.Text = "OFF (Press "..keyNames[camlockKey]..")"
    statusText.Font = Enum.Font.Gotham
    statusText.TextSize = 13
    statusText.TextColor3 = Color3.fromRGB(200, 200, 200)
    statusText.TextXAlignment = Enum.TextXAlignment.Left
    statusText.Parent = statusContainer
    
    -- Status indicator (circle)
    local statusIndicator = Instance.new("Frame")
    statusIndicator.Name = "StatusIndicator"
    statusIndicator.Size = UDim2.new(0, 10, 0, 10)
    statusIndicator.Position = UDim2.new(0.53, 0, 0.5, -5)
    statusIndicator.BackgroundColor3 = Color3.fromRGB(255, 0, 0) -- Red when off
    statusIndicator.BorderSizePixel = 0
    statusIndicator.Parent = statusContainer
    
    -- Make the indicator circular
    local indicatorCorner = Instance.new("UICorner")
    indicatorCorner.CornerRadius = UDim.new(1, 0)
    indicatorCorner.Parent = statusIndicator
    
    -- Change camlock key button with gradient
    local changeCamlockKeyButton = Instance.new("TextButton")
    changeCamlockKeyButton.Name = "ChangeCamlockKey"
    changeCamlockKeyButton.Size = UDim2.new(0.25, 0, 0, 26)
    changeCamlockKeyButton.Position = UDim2.new(0.72, 0, 0, 2)
    changeCamlockKeyButton.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
    changeCamlockKeyButton.BorderSizePixel = 0
    changeCamlockKeyButton.Text = "Change"
    changeCamlockKeyButton.Font = Enum.Font.GothamSemibold
    changeCamlockKeyButton.TextSize = 12
    changeCamlockKeyButton.TextColor3 = Color3.fromRGB(230, 230, 230)
    changeCamlockKeyButton.Parent = statusContainer
    
    -- Round button corners
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 6)
    buttonCorner.Parent = changeCamlockKeyButton
    
    -- Button gradient
    local buttonGradient = Instance.new("UIGradient")
    buttonGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(60, 60, 70)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(45, 45, 55))
    })
    buttonGradient.Rotation = 90
    buttonGradient.Parent = changeCamlockKeyButton
    
    -- Add hover effect to button
    changeCamlockKeyButton.MouseEnter:Connect(function()
        changeCamlockKeyButton.BackgroundColor3 = Color3.fromRGB(70, 70, 80)
    end)
    
    changeCamlockKeyButton.MouseLeave:Connect(function()
        changeCamlockKeyButton.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
    end)
    
    -- Section for smoothness slider
    local smoothnessSection = Instance.new("Frame")
    smoothnessSection.Name = "SmoothnessSection"
    smoothnessSection.Size = UDim2.new(1, 0, 0, 50)
    smoothnessSection.Position = UDim2.new(0, 0, 0, 60)
    smoothnessSection.BackgroundTransparency = 1
    smoothnessSection.Parent = camlockSection
    
    -- Smoothness label
    local smoothnessLabel = Instance.new("TextLabel")
    smoothnessLabel.Name = "SmoothnessLabel"
    smoothnessLabel.Size = UDim2.new(1, 0, 0, 20)
    smoothnessLabel.BackgroundTransparency = 1
    smoothnessLabel.Text = "SMOOTHNESS"
    smoothnessLabel.Font = Enum.Font.GothamBold
    smoothnessLabel.TextSize = 12
    smoothnessLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    smoothnessLabel.TextXAlignment = Enum.TextXAlignment.Left
    smoothnessLabel.Parent = smoothnessSection
    
    -- Smoothness value display
    local smoothnessValue = Instance.new("TextLabel")
    smoothnessValue.Name = "SmoothnessValue"
    smoothnessValue.Size = UDim2.new(0, 40, 0, 20)
    smoothnessValue.Position = UDim2.new(1, -40, 0, 0)
    smoothnessValue.BackgroundTransparency = 1
    smoothnessValue.Text = tostring(smoothness)
    smoothnessValue.Font = Enum.Font.GothamSemibold
    smoothnessValue.TextSize = 12
    smoothnessValue.TextColor3 = Color3.fromRGB(255, 255, 255)
    smoothnessValue.TextXAlignment = Enum.TextXAlignment.Right
    smoothnessValue.Parent = smoothnessSection
    
    -- Smoothness slider background
    local smoothnessSliderBackground = Instance.new("Frame")
    smoothnessSliderBackground.Name = "SliderBackground"
    smoothnessSliderBackground.Size = UDim2.new(1, 0, 0, 6)
    smoothnessSliderBackground.Position = UDim2.new(0, 0, 0, 30)
    smoothnessSliderBackground.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    smoothnessSliderBackground.BorderSizePixel = 0
    smoothnessSliderBackground.Parent = smoothnessSection
    
    -- Round slider background corners
    local sliderCorner = Instance.new("UICorner")
    sliderCorner.CornerRadius = UDim.new(0, 3)
    sliderCorner.Parent = smoothnessSliderBackground
    
    -- Smoothness slider fill (white)
    local smoothnessSliderFill = Instance.new("Frame")
    smoothnessSliderFill.Name = "SliderFill"
    smoothnessSliderFill.Size = UDim2.new(smoothness, 0, 1, 0)
    smoothnessSliderFill.BackgroundColor3 = Color3.fromRGB(255, 255, 255) -- White fill
    smoothnessSliderFill.BorderSizePixel = 0
    smoothnessSliderFill.Parent = smoothnessSliderBackground
    
    -- Round slider fill corners
    local fillCorner = Instance.new("UICorner")
    fillCorner.CornerRadius = UDim.new(0, 3)
    fillCorner.Parent = smoothnessSliderFill
    
    -- Smoothness slider knob
    local smoothnessSliderKnob = Instance.new("Frame")
    smoothnessSliderKnob.Name = "SliderKnob"
    smoothnessSliderKnob.Size = UDim2.new(0, 16, 0, 16)
    smoothnessSliderKnob.Position = UDim2.new(smoothness, 0, 0.5, 0)
    smoothnessSliderKnob.AnchorPoint = Vector2.new(0.5, 0.5)
    smoothnessSliderKnob.BackgroundColor3 = Color3.fromRGB(200, 200, 200)
    smoothnessSliderKnob.BorderSizePixel = 0
    smoothnessSliderKnob.ZIndex = 2
    smoothnessSliderKnob.Parent = smoothnessSliderBackground
    
    -- Round the knob
    local knobCorner = Instance.new("UICorner")
    knobCorner.CornerRadius = UDim.new(1, 0)
    knobCorner.Parent = smoothnessSliderKnob
    
    -- =============== WALKSPEED SECTION WITH SLIDER ===============
    local walkspeedSection = Instance.new("Frame")
    walkspeedSection.Name = "WalkspeedSection"
    walkspeedSection.Size = UDim2.new(1, 0, 0, 110) -- Taller to fit speed slider
    walkspeedSection.Position = UDim2.new(0, 0, 0, 120) -- Position after camlock section
    walkspeedSection.BackgroundTransparency = 1
    walkspeedSection.Parent = contentContainer
    
    -- Walkspeed section title
    local walkspeedTitle = Instance.new("TextLabel")
    walkspeedTitle.Name = "SectionTitle"
    walkspeedTitle.Size = UDim2.new(1, 0, 0, 20)
    walkspeedTitle.BackgroundTransparency = 1
    walkspeedTitle.Text = "WALKSPEED"
    walkspeedTitle.Font = Enum.Font.GothamBold
    walkspeedTitle.TextSize = 12
    walkspeedTitle.TextColor3 = Color3.fromRGB(255, 255, 255) -- Pure white
    walkspeedTitle.TextXAlignment = Enum.TextXAlignment.Left
    walkspeedTitle.Parent = walkspeedSection
    
    -- Walkspeed Status container
    local walkspeedStatusContainer = Instance.new("Frame")
    walkspeedStatusContainer.Name = "WalkspeedStatusContainer"
    walkspeedStatusContainer.Size = UDim2.new(1, 0, 0, 30)
    walkspeedStatusContainer.Position = UDim2.new(0, 0, 0, 20)
    walkspeedStatusContainer.BackgroundColor3 = Color3.fromRGB(25, 25, 35) -- Darker background
    walkspeedStatusContainer.BorderSizePixel = 0
    walkspeedStatusContainer.Parent = walkspeedSection
    
    -- Round the corners
    local walkspeedStatusCorner = statusCorner:Clone()
    walkspeedStatusCorner.Parent = walkspeedStatusContainer
    
    -- Walkspeed status text
    local walkspeedStatusText = Instance.new("TextLabel")
    walkspeedStatusText.Name = "WalkspeedStatusText"
    walkspeedStatusText.Size = UDim2.new(0.65, 0, 1, 0)
    walkspeedStatusText.Position = UDim2.new(0.03, 0, 0, 0)
    walkspeedStatusText.BackgroundTransparency = 1
    walkspeedStatusText.Text = "OFF (Press "..keyNames[walkspeedKey]..")"
    walkspeedStatusText.Font = Enum.Font.Gotham
    walkspeedStatusText.TextSize = 13
    walkspeedStatusText.TextColor3 = Color3.fromRGB(200, 200, 200)
    walkspeedStatusText.TextXAlignment = Enum.TextXAlignment.Left
    walkspeedStatusText.Parent = walkspeedStatusContainer
    
    -- Walkspeed status indicator (circle)
    local walkspeedStatusIndicator = Instance.new("Frame")
    walkspeedStatusIndicator.Name = "WalkspeedStatusIndicator"
    walkspeedStatusIndicator.Size = UDim2.new(0, 12, 0, 12)
    walkspeedStatusIndicator.Position = UDim2.new(0.97, 0, 0.5, 0)
    walkspeedStatusIndicator.AnchorPoint = Vector2.new(1, 0.5)
    walkspeedStatusIndicator.BackgroundColor3 = Color3.fromRGB(255, 0, 0) -- Red when off
    walkspeedStatusIndicator.BorderSizePixel = 0
    walkspeedStatusIndicator.Parent = walkspeedStatusContainer
    
    -- Make the indicator circular
    local walkspeedIndicatorCorner = Instance.new("UICorner")
    walkspeedIndicatorCorner.CornerRadius = UDim.new(1, 0)
    walkspeedIndicatorCorner.Parent = walkspeedStatusIndicator
    
    -- Store walkspeed UI elements in the guiElements table for access in other functions
    guiElements.walkspeedStatusText = walkspeedStatusText
    guiElements.walkspeedStatusIndicator = walkspeedStatusIndicator
    
    -- Change walkspeed key button
    local changeWalkspeedKeyButton = changeCamlockKeyButton:Clone()
    changeWalkspeedKeyButton.Name = "ChangeWalkspeedKey"
    changeWalkspeedKeyButton.Parent = walkspeedStatusContainer
    
    -- Add walkspeed slider section
    local walkspeedSliderSection = Instance.new("Frame")
    walkspeedSliderSection.Name = "WalkspeedSliderSection"
    walkspeedSliderSection.Size = UDim2.new(1, 0, 0, 50)
    walkspeedSliderSection.Position = UDim2.new(0, 0, 0, 60) -- Below status container
    walkspeedSliderSection.BackgroundTransparency = 1
    walkspeedSliderSection.Parent = walkspeedSection
    
    -- Speed slider label
    local walkspeedSliderLabel = Instance.new("TextLabel")
    walkspeedSliderLabel.Name = "SpeedLabel"
    walkspeedSliderLabel.Size = UDim2.new(1, 0, 0, 20)
    walkspeedSliderLabel.BackgroundTransparency = 1
    walkspeedSliderLabel.Text = "WALKSPEED"
    walkspeedSliderLabel.Font = Enum.Font.GothamBold
    walkspeedSliderLabel.TextSize = 12
    walkspeedSliderLabel.TextColor3 = Color3.fromRGB(255, 255, 255) -- Pure white
    walkspeedSliderLabel.TextXAlignment = Enum.TextXAlignment.Left
    walkspeedSliderLabel.Parent = walkspeedSliderSection
    
    -- Speed value display
    local walkspeedValue = Instance.new("TextLabel")
    walkspeedValue.Name = "SpeedValue"
    walkspeedValue.Size = UDim2.new(0, 40, 0, 20)
    walkspeedValue.Position = UDim2.new(1, -40, 0, 0)
    walkspeedValue.BackgroundTransparency = 1
    walkspeedValue.Text = tostring(walkspeed)
    walkspeedValue.Font = Enum.Font.GothamSemibold
    walkspeedValue.TextSize = 12
    walkspeedValue.TextColor3 = Color3.fromRGB(255, 255, 255) -- Pure white
    walkspeedValue.TextXAlignment = Enum.TextXAlignment.Right
    walkspeedValue.Parent = walkspeedSliderSection
    
    -- Speed slider background
    local walkspeedSliderBackground = Instance.new("Frame")
    walkspeedSliderBackground.Name = "SpeedSliderBackground"
    walkspeedSliderBackground.Size = UDim2.new(1, 0, 0, 6)
    walkspeedSliderBackground.Position = UDim2.new(0, 0, 0, 30)
    walkspeedSliderBackground.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    walkspeedSliderBackground.BorderSizePixel = 0
    walkspeedSliderBackground.Parent = walkspeedSliderSection
    
    -- Round slider background corners
    local walkspeedSliderCorner = Instance.new("UICorner")
    walkspeedSliderCorner.CornerRadius = UDim.new(0, 3)
    walkspeedSliderCorner.Parent = walkspeedSliderBackground
    
    -- Speed slider fill (white)
    local walkspeedSliderFill = Instance.new("Frame")
    walkspeedSliderFill.Name = "SpeedSliderFill"
    walkspeedSliderFill.Size = UDim2.new(walkspeed / 500, 0, 1, 0) -- Scale based on walkspeed (max 500)
    walkspeedSliderFill.BackgroundColor3 = Color3.fromRGB(255, 255, 255) -- White fill
    walkspeedSliderFill.BorderSizePixel = 0
    walkspeedSliderFill.Parent = walkspeedSliderBackground
    
    -- Round slider fill corners
    local walkspeedFillCorner = fillCorner:Clone()
    walkspeedFillCorner.Parent = walkspeedSliderFill
    
    -- Speed slider knob
    local walkspeedSliderKnob = Instance.new("Frame")
    walkspeedSliderKnob.Name = "SpeedSliderKnob"
    walkspeedSliderKnob.Size = UDim2.new(0, 16, 0, 16)
    walkspeedSliderKnob.Position = UDim2.new(walkspeed / 500, 0, 0.5, 0) -- Position based on walkspeed (max 500)
    walkspeedSliderKnob.AnchorPoint = Vector2.new(0.5, 0.5)
    walkspeedSliderKnob.BackgroundColor3 = Color3.fromRGB(200, 200, 200)
    walkspeedSliderKnob.BorderSizePixel = 0
    walkspeedSliderKnob.ZIndex = 2
    walkspeedSliderKnob.Parent = walkspeedSliderBackground
    
    -- Round the walkspeed knob
    local walkspeedKnobCorner = Instance.new("UICorner")
    walkspeedKnobCorner.CornerRadius = UDim.new(1, 0)
    walkspeedKnobCorner.Parent = walkspeedSliderKnob
    
    -- Store speed slider elements in guiElements
    guiElements.walkspeedValue = walkspeedValue
    guiElements.walkspeedSliderFill = walkspeedSliderFill
    guiElements.walkspeedSliderKnob = walkspeedSliderKnob
    
    -- Store other GUI elements in the guiElements table for access in other functions
    guiElements.mainFrame = mainFrame
    guiElements.statusText = statusText
    guiElements.statusIndicator = statusIndicator
    guiElements.smoothnessValue = smoothnessValue
    guiElements.smoothnessSliderFill = smoothnessSliderFill
    guiElements.smoothnessSliderKnob = smoothnessSliderKnob
    
    -- Make the sliders interactive
    local sliderConnection = UserInputService.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            -- Check if click is on smoothness slider
            local smoothnessSliderPosition = smoothnessSliderBackground.AbsolutePosition
            local smoothnessSliderSize = smoothnessSliderBackground.AbsoluteSize
            local inputPosition = input.Position
            
            -- Check if click is on smoothness slider
            if inputPosition.X >= smoothnessSliderPosition.X and 
               inputPosition.X <= smoothnessSliderPosition.X + smoothnessSliderSize.X and
               inputPosition.Y >= smoothnessSliderPosition.Y and
               inputPosition.Y <= smoothnessSliderPosition.Y + smoothnessSliderSize.Y then
                
                -- Start smoothness slider dragging
                local draggingSmoothnessSlider = true
                
                local function updateSmoothnessSlider()
                    -- Calculate relative position
                    local relativeX = math.clamp((inputPosition.X - smoothnessSliderPosition.X) / smoothnessSliderSize.X, 0, 1)
                    
                    -- Update smoothness value (0 to 1)
                    smoothness = relativeX
                    smoothnessValue.Text = string.format("%.1f", smoothness)
                    
                    -- Update slider visuals
                    smoothnessSliderFill.Size = UDim2.new(smoothness, 0, 1, 0)
                    smoothnessSliderKnob.Position = UDim2.new(smoothness, 0, 0.5, 0)
                end
                
                updateSmoothnessSlider()
                
                -- Connect to input changed for dragging
                local smoothnessDragConnection
                smoothnessDragConnection = UserInputService.InputChanged:Connect(function(dragInput)
                    if draggingSmoothnessSlider and dragInput.UserInputType == Enum.UserInputType.MouseMovement then
                        inputPosition = dragInput.Position
                        updateSmoothnessSlider()
                    end
                end)
                
                -- Connect to input ended to stop dragging
                local smoothnessEndConnection
                smoothnessEndConnection = UserInputService.InputEnded:Connect(function(endInput)
                    if endInput.UserInputType == Enum.UserInputType.MouseButton1 then
                        draggingSmoothnessSlider = false
                        smoothnessDragConnection:Disconnect()
                        smoothnessEndConnection:Disconnect()
                    end
                end)
            end
            
            -- Check if click is on walkspeed slider
            local walkspeedSliderPosition = walkspeedSliderBackground.AbsolutePosition
            local walkspeedSliderSize = walkspeedSliderBackground.AbsoluteSize
            
            if inputPosition.X >= walkspeedSliderPosition.X and 
               inputPosition.X <= walkspeedSliderPosition.X + walkspeedSliderSize.X and
               inputPosition.Y >= walkspeedSliderPosition.Y and
               inputPosition.Y <= walkspeedSliderPosition.Y + walkspeedSliderSize.Y then
                
                -- Start walkspeed slider dragging
                local draggingWalkspeedSlider = true
                
                local function updateWalkspeedSlider()
                    -- Calculate relative position
                    local relativePosX = math.clamp((inputPosition.X - walkspeedSliderPosition.X) / walkspeedSliderSize.X, 0, 1)
                    
                    -- Update walkspeed value (max 500)
                    walkspeed = math.floor(relativePosX * 500)
                    walkspeedValue.Text = tostring(walkspeed)
                    
                    -- Update slider visuals
                    walkspeedSliderFill.Size = UDim2.new(relativePosX, 0, 1, 0)
                    walkspeedSliderKnob.Position = UDim2.new(relativePosX, 0, 0.5, 0)
                    
                    -- Apply immediately if walkspeed is enabled
                    if walkspeedActive and localPlayer.Character and 
                       localPlayer.Character:FindFirstChildOfClass("Humanoid") then
                       
                        -- Aggressive application to override any game scripts
                        for i = 1, 3 do
                            task.spawn(function()
                                localPlayer.Character:FindFirstChildOfClass("Humanoid").WalkSpeed = walkspeed
                                task.wait(0.05)
                                localPlayer.Character:FindFirstChildOfClass("Humanoid").WalkSpeed = walkspeed
                            end)
                        end
                    end
                end
                
                updateWalkspeedSlider()
                
                -- Connect to input changed for dragging
                local walkspeedDragConnection
                walkspeedDragConnection = UserInputService.InputChanged:Connect(function(dragInput)
                    if draggingWalkspeedSlider and dragInput.UserInputType == Enum.UserInputType.MouseMovement then
                        inputPosition = dragInput.Position
                        updateWalkspeedSlider()
                    end
                end)
                
                -- Connect to input ended to stop dragging
                local walkspeedEndConnection
                walkspeedEndConnection = UserInputService.InputEnded:Connect(function(endInput)
                    if endInput.UserInputType == Enum.UserInputType.MouseButton1 then
                        draggingWalkspeedSlider = false
                        walkspeedDragConnection:Disconnect()
                        walkspeedEndConnection:Disconnect()
                    end
                end)
            end
        end
    end)
    
    -- Store the connection for cleanup
    table.insert(connections, sliderConnection)
    
    -- Handle key rebinding for camlock
    local isRebindingCamlock = false
    
    changeCamlockKeyButton.MouseButton1Click:Connect(function()
        if not isRebindingCamlock then
            isRebindingCamlock = true
            changeCamlockKeyButton.Text = "Press Key"
            
            local keyPressConnection
            keyPressConnection = UserInputService.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.Keyboard then
                    camlockKey = input.KeyCode
                    keyNames[camlockKey] = input.KeyCode.Name
                    changeCamlockKeyButton.Text = "Change"
                    statusText.Text = "OFF (Press "..keyNames[camlockKey]..")"
                    isRebindingCamlock = false
                    keyPressConnection:Disconnect()
                end
            end)
        end
    end)
    
    -- Handle key rebinding for walkspeed
    local isRebindingWalkspeed = false
    
    changeWalkspeedKeyButton.MouseButton1Click:Connect(function()
        if not isRebindingWalkspeed then
            isRebindingWalkspeed = true
            changeWalkspeedKeyButton.Text = "Press Key"
            
            local keyPressConnection
            keyPressConnection = UserInputService.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.Keyboard then
                    walkspeedKey = input.KeyCode
                    keyNames[walkspeedKey] = input.KeyCode.Name
                    changeWalkspeedKeyButton.Text = "Change"
                    walkspeedStatusText.Text = "OFF (Press "..keyNames[walkspeedKey]..")"
                    isRebindingWalkspeed = false
                    keyPressConnection:Disconnect()
                end
            end)
        end
    end)
    
    -- Handle the close button click
    closeButton.MouseButton1Click:Connect(function()
        unloadScript()
    end)
    
    -- Add the GUI to the player's screen with enhanced compatibility
    print("Attempting to make GUI visible with multiple methods...")
    
    -- Store attempts to debug visibility issues
    local visibilityAttempts = {}
    
    -- First try all exploit-specific methods
    if syn and syn.protect_gui then
        table.insert(visibilityAttempts, "Synapse X method")
        syn.protect_gui(screenGui)
        screenGui.Parent = game:GetService("CoreGui")
    elseif protect_gui then
        table.insert(visibilityAttempts, "protect_gui method")
        protect_gui(screenGui)
        screenGui.Parent = game:GetService("CoreGui")
    elseif KRNL_LOADED and get_hidden_gui then
        table.insert(visibilityAttempts, "KRNL method")
        screenGui.Parent = get_hidden_gui()
    elseif gethui then
        table.insert(visibilityAttempts, "gethui method")
        screenGui.Parent = gethui()
    elseif gethiddengui then
        table.insert(visibilityAttempts, "gethiddengui method")
        screenGui.Parent = gethiddengui()
    elseif hiddenUI then
        table.insert(visibilityAttempts, "hiddenUI method")
        screenGui.Parent = hiddenUI
    elseif game:GetService("CoreGui"):FindFirstChild("RobloxGui") then
        table.insert(visibilityAttempts, "RobloxGui method")
        screenGui.Parent = game:GetService("CoreGui").RobloxGui
    else
        -- Attempt standard methods as fallbacks
        table.insert(visibilityAttempts, "Standard PlayerGui method")
        pcall(function() screenGui.Parent = localPlayer:FindFirstChildOfClass("PlayerGui") end)
    end
    
    -- If nothing has worked, try direct methods
    if not screenGui.Parent or screenGui.Parent == nil then
        table.insert(visibilityAttempts, "Direct CoreGui method")
        pcall(function() screenGui.Parent = game:GetService("CoreGui") end)
    end
    
    -- Last resort direct PlayerGui
    if not screenGui.Parent or screenGui.Parent == nil then
        table.insert(visibilityAttempts, "Direct PlayerGui method (last resort)")
        pcall(function() screenGui.Parent = game:GetService("Players").LocalPlayer:FindFirstChildOfClass("PlayerGui") end)
    end
    
    -- Print all attempts for debugging
    print("GUI visibility attempts:", table.concat(visibilityAttempts, ", "))
    
    -- Force update GUI visibility properties to ensure it shows
    screenGui.IgnoreGuiInset = true
    screenGui.DisplayOrder = 999
    screenGui.ZIndex = 9999
    
    -- Make GUI elements visible explicitly
    mainFrame.Visible = true
    
    -- Configure ResetOnSpawn to ensure the GUI persists
    screenGui.ResetOnSpawn = false
    
    -- Force a redraw
    task.spawn(function()
        task.wait(0.1)
        if mainFrame and mainFrame:IsDescendantOf(game) then
            local oldPos = mainFrame.Position
            mainFrame.Position = oldPos + UDim2.new(0, 1, 0, 0)
            task.wait()
            mainFrame.Position = oldPos
        end
    end)
    
    print("GUI creation complete, should now be visible")
end

-- Function to find the closest player for targeting
local function findClosestPlayer()
    local closestPlayer = nil
    local closestDistance = maxDistance
    
    for _, player in pairs(Players:GetPlayers()) do
        -- Skip ourselves
        if player ~= localPlayer then
            -- Make sure both the local player and the target have characters
            if localPlayer.Character and player.Character then
                -- Check if the target player has a HumanoidRootPart and Head
                if player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Head") then
                    -- Calculate distance between us and them
                    local distance = (localPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
                    
                    -- If they're closer than the current closest, update
                    if distance < closestDistance then
                        closestPlayer = player
                        closestDistance = distance
                    end
                end
            end
        end
    end
    
    return closestPlayer
end

-- Function to apply highlight effect to a targeted player
local function applyHighlight(player)
    -- Remove any existing highlight
    if highlight then
        highlight:Destroy()
        highlight = nil
    end
    
    -- Apply new highlight if player has a character
    if player and player.Character then
        -- Create a new highlight
        highlight = Instance.new("Highlight")
        highlight.Name = "TargetHighlight"
        highlight.FillColor = Color3.fromRGB(255, 0, 0)  -- Red color
        highlight.FillTransparency = 0.7  -- 70% transparency to see through it
        highlight.OutlineColor = Color3.fromRGB(255, 0, 0)  -- Red outline
        highlight.OutlineTransparency = 0.3  -- 30% transparency for outline
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop  -- Make it visible through walls
        highlight.Adornee = player.Character  -- Apply to the whole character
        highlight.Parent = player.Character  -- Parent to the character
    end
end

-- Function to toggle the targeting system on/off
local function toggleTargeting()
    isTargeting = not isTargeting
    
    if isTargeting then
        -- When targeting is turned on, find a target
        guiElements.statusText.Text = "ON (Press "..keyNames[camlockKey]..")"
        guiElements.statusText.TextColor3 = Color3.fromRGB(0, 255, 0)
        guiElements.statusIndicator.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
        
        -- Find the target player
        targetPlayer = findClosestPlayer()
        print("Target player found:", targetPlayer and targetPlayer.Name or "none")
        
        -- Apply highlight to the targeted player
        if targetPlayer then
            applyHighlight(targetPlayer)
        end
    else
        -- When targeting is turned off, clear the target
        guiElements.statusText.Text = "OFF (Press "..keyNames[camlockKey]..")"
        guiElements.statusText.TextColor3 = Color3.fromRGB(200, 200, 200)
        guiElements.statusIndicator.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
        targetPlayer = nil
        
        -- Remove highlight
        if highlight then
            highlight:Destroy()
            highlight = nil
        end
    end
    
    -- Print confirmation
    print("Targeting toggled to:", isTargeting)
end

-- Function to initialize walkspeed - store original value
local function initWalkspeed()
    if not originalWalkspeed and localPlayer and localPlayer.Character then
        local humanoid = localPlayer.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            originalWalkspeed = humanoid.WalkSpeed
            print("Original walkspeed stored:", originalWalkspeed)
        end
    end
end

-- Function to toggle GUI visibility
local function toggleGuiVisibility()
    if guiElements.mainFrame then
        guiVisible = not guiVisible
        guiElements.mainFrame.Visible = guiVisible
        print("GUI visibility toggled to:", guiVisible)
    end
end

-- Function to toggle walkspeed on/off with smooth transitions
local function toggleWalkspeed()
    -- Initialize if needed
    if not originalWalkspeed then
        initWalkspeed()
    end
    
    -- Toggle the state
    walkspeedActive = not walkspeedActive
    
    -- Update UI
    if walkspeedActive then
        -- Turn on walkspeed with visual feedback
        guiElements.walkspeedStatusText.Text = "ON (Press "..keyNames[walkspeedKey]..")"
        guiElements.walkspeedStatusText.TextColor3 = Color3.fromRGB(0, 255, 0)
        guiElements.walkspeedStatusIndicator.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
        
        -- Apply walkspeed with smooth acceleration
        if localPlayer.Character and localPlayer.Character:FindFirstChildOfClass("Humanoid") then
            local humanoid = localPlayer.Character:FindFirstChildOfClass("Humanoid")
            local currentSpeed = humanoid.WalkSpeed
            local targetSpeed = walkspeed
            local duration = 0.35 -- Smooth acceleration over time
            
            -- Immediate response for feedback
            humanoid.WalkSpeed = currentSpeed + (targetSpeed - currentSpeed) * 0.3
            
            -- Smooth transition to target speed
            task.spawn(function()
                local startTime = tick()
                local endTime = startTime + duration
                
                while tick() < endTime and walkspeedActive do
                    -- Calculate progress with smoothstep easing
                    local progress = (tick() - startTime) / duration
                    progress = math.clamp(progress, 0, 1)
                    local easedProgress = progress * progress * (3 - 2 * progress)
                    
                    -- Apply interpolated speed
                    local newSpeed = currentSpeed + (targetSpeed - currentSpeed) * easedProgress
                    if humanoid and humanoid.Parent then
                        humanoid.WalkSpeed = newSpeed
                    else
                        break
                    end
                    
                    -- High frequency updates for smoothness
                    task.wait(1/60)
                end
                
                -- Final application at exact target
                if walkspeedActive and humanoid and humanoid.Parent then
                    humanoid.WalkSpeed = targetSpeed
                end
            end)
        end
    else
        -- Turn off walkspeed with visual feedback
        guiElements.walkspeedStatusText.Text = "OFF (Press "..keyNames[walkspeedKey]..")"
        guiElements.walkspeedStatusText.TextColor3 = Color3.fromRGB(200, 200, 200)
        guiElements.walkspeedStatusIndicator.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
        
        -- Reset walkspeed to original value with smooth deceleration
        if localPlayer.Character and localPlayer.Character:FindFirstChildOfClass("Humanoid") then
            local humanoid = localPlayer.Character:FindFirstChildOfClass("Humanoid")
            local currentSpeed = humanoid.WalkSpeed
            local targetSpeed = originalWalkspeed or 16
            local duration = 0.3 -- Slightly faster deceleration
            
            -- Smooth transition back to normal speed
            task.spawn(function()
                local startTime = tick()
                local endTime = startTime + duration
                
                while tick() < endTime and not walkspeedActive do
                    -- Calculate progress with smoothstep easing for deceleration
                    local progress = (tick() - startTime) / duration
                    progress = math.clamp(progress, 0, 1)
                    local easedProgress = progress * progress * (3 - 2 * progress)
                    
                    -- Apply interpolated speed for deceleration
                    local newSpeed = currentSpeed + (targetSpeed - currentSpeed) * easedProgress
                    if humanoid and humanoid.Parent then
                        humanoid.WalkSpeed = newSpeed
                    else
                        break
                    end
                    
                    -- High frequency updates for smoothness
                    task.wait(1/60)
                end
                
                -- Final application at exact target
                if not walkspeedActive and humanoid and humanoid.Parent then
                    humanoid.WalkSpeed = targetSpeed
                end
            end)
        end
    end
    
    print("Walkspeed toggled to: " .. tostring(walkspeedActive) .. ", value: " .. tostring(walkspeed))
end

-- Enhanced super-smooth walkspeed system
local function createWalkspeedThreads()
    -- Variables for smooth transitions
    local currentTargetSpeed = walkspeed
    local transitionDuration = 0.3 -- Duration of smooth transition in seconds
    local updateFrequency = 60 -- Updates per second for ultra-smooth transition
    local lastGameSetSpeed = nil
    local isTransitioning = false
    
    -- Easing function for smooth transitions (smoothstep)
    local function smoothstep(t)
        return t * t * (3 - 2 * t) -- Smooth acceleration and deceleration
    end
    
    -- Function to smoothly transition between speeds
    local function smoothTransition(from, to, duration)
        if isTransitioning then return end
        isTransitioning = true
        
        local steps = math.floor(duration * updateFrequency)
        local startTime = tick()
        local endTime = startTime + duration
        
        -- Create separate thread for the transition
        task.spawn(function()
            while tick() < endTime and walkspeedActive do
                if localPlayer.Character then
                    local humanoid = localPlayer.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        -- Calculate progress through transition
                        local progress = (tick() - startTime) / duration
                        progress = math.clamp(progress, 0, 1)
                        
                        -- Apply easing function
                        local easedProgress = smoothstep(progress)
                        
                        -- Calculate and apply interpolated speed
                        local newSpeed = from + (to - from) * easedProgress
                        humanoid.WalkSpeed = newSpeed
                        
                        -- Ultra-smooth update rate
                        task.wait(1/updateFrequency)
                    else
                        break
                    end
                else
                    break
                end
            end
            
            -- Ensure we end exactly at target value
            if walkspeedActive and localPlayer.Character then
                local humanoid = localPlayer.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then humanoid.WalkSpeed = to end
            end
            
            isTransitioning = false
        end)
    end
    
    -- Thread 1: Primary high-precision application via RenderStepped
    local walkspeedRenderConnection = RunService.RenderStepped:Connect(function()
        if walkspeedActive and localPlayer and localPlayer.Character then
            local humanoid = localPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                -- Detect if target speed has changed (user moved slider)
                if currentTargetSpeed ~= walkspeed and not isTransitioning then
                    local oldTarget = currentTargetSpeed
                    currentTargetSpeed = walkspeed
                    smoothTransition(oldTarget, currentTargetSpeed, transitionDuration)
                end
                
                -- Handle game overwrites more intelligently
                if not isTransitioning and math.abs(humanoid.WalkSpeed - currentTargetSpeed) > 0.5 then
                    -- Game may have set a new speed - detect significant changes
                    if lastGameSetSpeed == nil or math.abs(lastGameSetSpeed - humanoid.WalkSpeed) > 5 then
                        lastGameSetSpeed = humanoid.WalkSpeed
                        print("Detected game speed change, smoothly transitioning to desired speed")
                        smoothTransition(humanoid.WalkSpeed, currentTargetSpeed, transitionDuration/2)
                    else
                        -- Minor correction, apply directly
                        humanoid.WalkSpeed = currentTargetSpeed
                    end
                end
            end
        end
    end)
    table.insert(connections, walkspeedRenderConnection)
    
    -- Thread 2: Secondary maintenance via Heartbeat (different timing than RenderStepped)
    local walkspeedUpdateConnection = RunService.Heartbeat:Connect(function()
        if walkspeedActive and localPlayer and localPlayer.Character and not isTransitioning then
            local humanoid = localPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                -- Gentle maintenance - only correct if significantly off target
                if math.abs(humanoid.WalkSpeed - currentTargetSpeed) > 1 then
                    humanoid.WalkSpeed = currentTargetSpeed
                end
            end
        end
    end)
    table.insert(connections, walkspeedUpdateConnection)
    
    -- Thread 3: Background stability monitoring with progressive response
    task.spawn(function()
        local consecutiveOverwrites = 0
        
        while true do
            if walkspeedActive and localPlayer and localPlayer.Character and not isTransitioning then
                local humanoid = localPlayer.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    -- Is the game aggressively fighting our speed settings?
                    if math.abs(humanoid.WalkSpeed - currentTargetSpeed) > 2 then
                        consecutiveOverwrites = consecutiveOverwrites + 1
                        
                        -- Escalating response based on how persistent the game is
                        if consecutiveOverwrites > 3 then
                            print("Game is persistently overriding walkspeed, applying escalating correction")
                            
                            -- Staggered reapplication pattern to outsmart game logic
                            for i = 1, 5 do
                                task.spawn(function()
                                    -- Staggered timing to bypass rate limiters
                                    task.wait(i * 0.02 + math.random() * 0.01)
                                    if walkspeedActive and localPlayer.Character then
                                        local h = localPlayer.Character:FindFirstChildOfClass("Humanoid")
                                        if h then h.WalkSpeed = currentTargetSpeed end
                                    end
                                end)
                            end
                            
                            -- Reset counter after aggressive correction
                            consecutiveOverwrites = 0
                        else
                            -- Standard correction
                            humanoid.WalkSpeed = currentTargetSpeed
                        end
                    else
                        -- Speed is stable, reset counter
                        consecutiveOverwrites = math.max(0, consecutiveOverwrites - 1)
                    end
                end
            end
            task.wait(0.1) -- Check 10 times per second
        end
    end)
    
    -- Thread 4: Special handling for extreme cases
    task.spawn(function()
        while true do
            if walkspeedActive and localPlayer and localPlayer.Character then
                local humanoid = localPlayer.Character:FindFirstChildOfClass("Humanoid")
                
                -- Handle extreme speed discrepancies
                if humanoid and math.abs(humanoid.WalkSpeed - currentTargetSpeed) > 20 then
                    print("Critical walkspeed discrepancy detected")
                    
                    -- Try to determine if it's a character change or a game override
                    if humanoid.WalkSpeed == 16 then -- Default Roblox walkspeed
                        -- Likely a new character or reset - use normal transition
                        smoothTransition(16, currentTargetSpeed, transitionDuration/2)
                    else
                        -- Possible aggressive game override - apply immediate correction
                        humanoid.WalkSpeed = currentTargetSpeed
                    end
                end
            end
            task.wait(0.3) -- Less frequent check for extreme cases
        end
    end)
    
    print("Super-smooth walkspeed system initialized")
end

-- Initialize the walkspeed threads
createWalkspeedThreads()

-- Variable no longer in this scope, removed reference

-- Connect to the character added event for respawns with smooth transition
local characterAddedConnection = localPlayer.CharacterAdded:Connect(function(character)
    task.wait(0.5) -- Wait for character to fully load
    
    if walkspeedActive then
        local humanoid = character:WaitForChild("Humanoid")
        if humanoid then
            -- First apply immediately to ensure some effect
            humanoid.WalkSpeed = walkspeed
            
            -- Then start a smooth transition from default to target
            task.spawn(function()
                -- Smoothly accelerate from default speed to target walkspeed
                local defaultSpeed = 16 -- Default Roblox speed
                local targetSpeed = walkspeed
                local duration = 0.4 -- Slightly longer for respawn transition
                local startTime = tick()
                local endTime = startTime + duration
                
                -- Smooth acceleration after respawn
                while tick() < endTime and walkspeedActive do
                    if humanoid and humanoid.Parent then
                        -- Calculate smoothed progress
                        local progress = (tick() - startTime) / duration
                        progress = math.clamp(progress, 0, 1)
                        
                        -- Use easing function for smooth acceleration
                        local easedProgress = progress * progress * (3 - 2 * progress)
                        
                        -- Apply interpolated speed for super smooth acceleration
                        local newSpeed = defaultSpeed + (targetSpeed - defaultSpeed) * easedProgress
                        humanoid.WalkSpeed = newSpeed
                        
                        -- Update at 60fps for ultra smooth visual transition
                        task.wait(1/60)
                    else
                        break
                    end
                end
                
                -- Final application at exact target speed
                if walkspeedActive and humanoid and humanoid.Parent then
                    humanoid.WalkSpeed = targetSpeed
                end
            end)
            print("Smoothly applying walkspeed after respawn to:", walkspeed)
        end
    end
end)

-- Store the connection for cleanup
table.insert(connections, characterAddedConnection)

-- Connect to the input service to detect key presses
local inputConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
    -- Only process if we're not in a text box or something
    if not gameProcessed then
        -- Check if the camlock key was pressed to toggle targeting
        if input.KeyCode == camlockKey then
            toggleTargeting()
        end
        
        -- Check if the walkspeed key was pressed
        if input.KeyCode == walkspeedKey then
            toggleWalkspeed()
        end
        
        -- Check if the GUI toggle key (Right Ctrl) was pressed
        if input.KeyCode == toggleGuiKey then
            toggleGuiVisibility()
        end
    end
end)

-- Store the connection for cleanup
table.insert(connections, inputConnection)

-- Function that runs every frame to update the camera if targeting is on
local function updateCamera()
    -- Only run the targeting code if the necessary conditions are met
    if isTargeting and targetPlayer and 
       localPlayer.Character and targetPlayer.Character and
       localPlayer.Character:FindFirstChild("HumanoidRootPart") and
       targetPlayer.Character:FindFirstChild("Head") then
        
        -- Get the positions we need
        local rootPosition = localPlayer.Character.HumanoidRootPart.Position
        local targetPosition = targetPlayer.Character.Head.Position
        
        -- Even if target is out of range, keep targeting the same player
        -- (The camera lock will stay on until manually toggled off by pressing C)
        
        -- Apply highlight to the targeted player regardless of camera mode
        if highlight == nil or targetPlayer.Character ~= highlight.Adornee then
            applyHighlight(targetPlayer)
        end

        -- Always control the camera when targeting is on
        local currentCFrame = camera.CFrame
        
        -- Get the target CFrame (where we want the camera to look)
        local targetCFrame = CFrame.new(currentCFrame.Position, targetPosition)
        
        -- Smoothly interpolate between current and target CFrame based on smoothness
        camera.CFrame = currentCFrame:Lerp(targetCFrame, smoothness)
    end
end

-- Connect our camera update function to RunService's RenderStepped event
local cameraConnection = RunService.RenderStepped:Connect(updateCamera)

-- Store this connection for cleanup
table.insert(connections, cameraConnection)

-- Print initial instructions
print("=== ghst.lol Camera Lock Script ===")
print("Press 'C' to toggle camera lock on/off")
print("Press 'V' to toggle walkspeed mode")
print("Press 'Right Ctrl' to toggle GUI visibility")
print("Adjust smoothness and walkspeed with the sliders")
print("Change keybinds using the 'Change' buttons in the GUI")
print("Use the X button to unload the script and reset everything")
print("=== Created by ghst.lol ===")

-- Function to unload the script and clean everything up
function unloadScript()
    -- Clean up connections
    for _, connection in pairs(connections) do
        if connection then
            connection:Disconnect()
        end
    end
    
    -- Turn off targeting
    isTargeting = false
    if highlight then
        highlight:Destroy()
        highlight = nil
    end
    
    -- Turn off walkspeed
    if walkspeedActive then
        walkspeedActive = false
        if localPlayer.Character and localPlayer.Character:FindFirstChildOfClass("Humanoid") then
            if originalWalkspeed then
                localPlayer.Character:FindFirstChildOfClass("Humanoid").WalkSpeed = originalWalkspeed
            else
                localPlayer.Character:FindFirstChildOfClass("Humanoid").WalkSpeed = 16 -- Default
            end
        end
    end
    
    -- Restore camera
    camera.CameraType = Enum.CameraType.Custom
    
    -- Remove GUI
    if guiElements.mainFrame and guiElements.mainFrame.Parent then
        local screenGui = guiElements.mainFrame.Parent
        screenGui:Destroy()
    end
    
    -- Print unload message
    print("=== ghst.lol has been unloaded ===")
end

-- Create the GUI to start the script
createGui()
